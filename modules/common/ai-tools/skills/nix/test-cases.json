[
  {
    "ruleId": "",
    "ruleTitle": "mkIf - Conditional Config Blocks",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = lib.mkEnableOption \"example module\";\n  };\n\n  # This breaks merging - other modules cannot add to programs.git if this condition is false\n  config = if cfg.enable then {\n    programs.git.enable = true;\n    programs.git.userName = \"user\";\n  } else {\n    programs.git.enable = false;\n  };\n}",
    "language": "nix",
    "description": "Top-level if-else"
  },
  {
    "ruleId": "",
    "ruleTitle": "mkIf - Conditional Config Blocks",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n  };\n\n  # This allows proper merging - other modules can still contribute to programs.git\n  config = mkIf cfg.enable {\n    programs.git = {\n      enable = true;\n      userName = \"user\";\n    };\n  };\n}",
    "language": "nix",
    "description": "mkIf"
  },
  {
    "ruleId": "",
    "ruleTitle": "mkMerge - Combine Conditionals",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    enableGit = mkEnableOption \"git support\";\n    enableVim = mkEnableOption \"vim support\";\n  };\n\n  # Hard to read with deeply nested conditionals\n  config = mkIf cfg.enable (\n    if cfg.enableGit then\n      {\n        programs.bash.enable = true;\n        programs.git.enable = true;\n      } // (\n        if cfg.enableVim then\n          { programs.vim.enable = true; }\n        else\n          { }\n      )\n    else\n      { programs.bash.enable = true; }\n  );\n}",
    "language": "nix",
    "description": "Nested spaghetti"
  },
  {
    "ruleId": "",
    "ruleTitle": "mkMerge - Combine Conditionals",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkMerge mkEnableOption;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    enableGit = mkEnableOption \"git support\";\n    enableVim = mkEnableOption \"vim support\";\n  };\n\n  # Clean separation of concerns with mkMerge\n  config = mkMerge [\n    # Always enabled when module is active\n    (mkIf cfg.enable {\n      programs.bash.enable = true;\n    })\n\n    # Conditional git support\n    (mkIf (cfg.enable && cfg.enableGit) {\n      programs.git.enable = true;\n    })\n\n    # Conditional vim support\n    (mkIf (cfg.enable && cfg.enableVim) {\n      programs.vim.enable = true;\n    })\n  ];\n}",
    "language": "nix",
    "description": "Clean Merge"
  },
  {
    "ruleId": "",
    "ruleTitle": "optionals - Conditional List Items",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    enableTools = mkEnableOption \"development tools\";\n  };\n\n  config = mkIf cfg.enable {\n    # Verbose and hard to read\n    home.packages = [ pkgs.coreutils ]\n      ++ (if cfg.enableTools then [ pkgs.ripgrep pkgs.fd ] else [ ])\n      ++ (if pkgs.stdenv.hostPlatform.isLinux then [ pkgs.strace ] else [ ]);\n  };\n}",
    "language": "nix",
    "description": "Ternary for lists"
  },
  {
    "ruleId": "",
    "ruleTitle": "optionals - Conditional List Items",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption optionals;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    enableTools = mkEnableOption \"development tools\";\n  };\n\n  config = mkIf cfg.enable {\n    # Clean and readable with optionals\n    home.packages = [\n      pkgs.coreutils\n    ]\n    ++ optionals cfg.enableTools [\n      pkgs.ripgrep\n      pkgs.fd\n    ]\n    ++ optionals pkgs.stdenv.hostPlatform.isLinux [\n      pkgs.strace\n    ];\n  };\n}",
    "language": "nix",
    "description": "optionals"
  },
  {
    "ruleId": "",
    "ruleTitle": "optionalString - Conditional Strings",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    enableAliases = mkEnableOption \"shell aliases\";\n  };\n\n  config = mkIf cfg.enable {\n    programs.bash.initExtra = ''\n      export EDITOR=vim\n    ''\n    # This throws type error - cannot concatenate null to string\n    + (if cfg.enableAliases then ''\n      alias ll='ls -la'\n      alias gs='git status'\n    '' else null);\n  };\n}",
    "language": "nix",
    "description": "If-then-else null"
  },
  {
    "ruleId": "",
    "ruleTitle": "optionalString - Conditional Strings",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption optionalString;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    enableAliases = mkEnableOption \"shell aliases\";\n  };\n\n  config = mkIf cfg.enable {\n    programs.bash.initExtra = ''\n      export EDITOR=vim\n    ''\n    + optionalString cfg.enableAliases ''\n      alias ll='ls -la'\n      alias gs='git status'\n    '';\n  };\n}",
    "language": "nix",
    "description": "optionalString"
  },
  {
    "ruleId": "",
    "ruleTitle": "Input Follows",
    "type": "bad",
    "code": "{\n  description = \"My NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n\n    # BAD - home-manager brings its own nixpkgs\n    # Now you have TWO nixpkgs instances, doubling evaluation time and closure size\n    home-manager.url = \"github:nix-community/home-manager\";\n\n    # BAD - Each input has its own nixpkgs copy\n    neovim-nightly.url = \"github:nix-community/neovim-nightly-overlay\";\n  };\n\n  outputs = { self, nixpkgs, home-manager, neovim-nightly }: {\n    # Configuration here - but with duplicated inputs\n  };\n}",
    "language": "nix",
    "description": "Duplicated Inputs"
  },
  {
    "ruleId": "",
    "ruleTitle": "Input Follows",
    "type": "good",
    "code": "{\n  description = \"My NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n\n    # GOOD - home-manager follows our nixpkgs\n    home-manager = {\n      url = \"github:nix-community/home-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n\n    # GOOD - All overlays use the same nixpkgs\n    neovim-nightly = {\n      url = \"github:nix-community/neovim-nightly-overlay\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n\n    # GOOD - Chain follows for nested dependencies\n    sops-nix = {\n      url = \"github:Mic92/sops-nix\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n      inputs.nixpkgs-stable.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs = { self, nixpkgs, home-manager, neovim-nightly, sops-nix }: {\n    # Configuration with single nixpkgs instance\n  };\n}",
    "language": "nix",
    "description": "Deduplicated"
  },
  {
    "ruleId": "",
    "ruleTitle": "Standard Flake Structure",
    "type": "bad",
    "code": "{\n  description = \"My project flake\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n  };\n\n  outputs = { self, nixpkgs }: {\n    # BAD - hardcoded system breaks on other architectures\n    packages.myPkg = nixpkgs.legacyPackages.x86_64-linux.hello;\n\n    # BAD - only works on x86_64-linux\n    devShells.default = nixpkgs.legacyPackages.x86_64-linux.mkShell {\n      buildInputs = [ nixpkgs.legacyPackages.x86_64-linux.git ];\n    };\n  };\n}",
    "language": "nix",
    "description": "Hardcoded System"
  },
  {
    "ruleId": "",
    "ruleTitle": "Standard Flake Structure",
    "type": "good",
    "code": "{\n  description = \"My project flake\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n  };\n\n  outputs = { self, nixpkgs }:\n    let\n      # Helper to generate attributes for all systems\n      forAllSystems = nixpkgs.lib.genAttrs [\n        \"x86_64-linux\"\n        \"aarch64-linux\"\n        \"aarch64-darwin\"\n        \"x86_64-darwin\"\n      ];\n    in\n    {\n      packages = forAllSystems (system:\n        let\n          pkgs = nixpkgs.legacyPackages.${system};\n        in\n        {\n          default = pkgs.hello;\n\n          myApp = pkgs.stdenv.mkDerivation {\n            name = \"my-app\";\n            src = ./.;\n            buildInputs = [ pkgs.git ];\n          };\n        }\n      );\n\n      devShells = forAllSystems (system:\n        let\n          pkgs = nixpkgs.legacyPackages.${system};\n        in\n        {\n          default = pkgs.mkShell {\n            buildInputs = [\n              pkgs.git\n              pkgs.nixpkgs-fmt\n            ];\n          };\n        }\n      );\n    };\n}",
    "language": "nix",
    "description": "Multi-System"
  },
  {
    "ruleId": "",
    "ruleTitle": "nix-darwin Module",
    "type": "bad",
    "code": "{ config, lib, ... }:\nlet\n  cfg = config.system.defaults.custom;\nin\n{\n  options.system.defaults.custom.enable = lib.mkEnableOption \"macOS tweaks\";\n\n  config = lib.mkIf cfg.enable {\n    # Wrong: These are Linux-specific\n    services.xserver.enable = true;\n    boot.loader.systemd-boot.enable = true;\n  };\n}",
    "language": "nix",
    "description": "Linux assumptions"
  },
  {
    "ruleId": "",
    "ruleTitle": "nix-darwin Module",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption mkOption types;\n  cfg = config.system.defaults.custom;\nin\n{\n  options.system.defaults.custom = {\n    enable = mkEnableOption \"macOS system tweaks\";\n\n    dockAutohide = mkOption {\n      type = types.bool;\n      default = true;\n      description = \"Automatically hide and show the Dock\";\n    };\n  };\n\n  config = mkIf cfg.enable {\n    # macOS system defaults\n    system.defaults = {\n      dock = {\n        autohide = cfg.dockAutohide;\n        mru-spaces = false;\n        show-recents = false;\n      };\n\n      finder = {\n        AppleShowAllExtensions = true;\n        FXEnableExtensionChangeWarning = false;\n      };\n\n      NSGlobalDomain = {\n        ApplePressAndHoldEnabled = false;\n        InitialKeyRepeat = 15;\n        KeyRepeat = 2;\n      };\n    };\n\n    # macOS-specific services\n    services.nix-daemon.enable = true;\n  };\n}",
    "language": "nix",
    "description": "MacOS Defaults"
  },
  {
    "ruleId": "",
    "ruleTitle": "Home Manager Module",
    "type": "bad",
    "code": "{ config, lib, pkgs, ... }:\nlet\n  cfg = config.programs.myApp;\nin\n{\n  options.programs.myApp.enable = lib.mkEnableOption \"My App\";\n\n  config = lib.mkIf cfg.enable {\n    # Wrong: These are system-level options\n    environment.systemPackages = [ pkgs.myApp ];\n    networking.hostName = \"my-host\";\n  };\n}",
    "language": "nix",
    "description": "System-level syntax"
  },
  {
    "ruleId": "",
    "ruleTitle": "Home Manager Module",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption mkOption types;\n  cfg = config.programs.myApp;\nin\n{\n  options.programs.myApp = {\n    enable = mkEnableOption \"My App\";\n\n    theme = mkOption {\n      type = types.enum [\n        \"light\"\n        \"dark\"\n      ];\n      default = \"dark\";\n      description = \"Color theme for the application\";\n    };\n  };\n\n  config = mkIf cfg.enable {\n    # User-level package installation\n    home.packages = [ pkgs.myApp ];\n\n    # XDG configuration file\n    xdg.configFile.\"myapp/config.toml\".text = ''\n      theme = \"${cfg.theme}\"\n      auto_save = true\n    '';\n\n    # Environment variables\n    home.sessionVariables = {\n      MYAPP_CONFIG = \"${config.xdg.configHome}/myapp/config.toml\";\n    };\n  };\n}",
    "language": "nix",
    "description": "User Application"
  },
  {
    "ruleId": "",
    "ruleTitle": "NixOS System Module",
    "type": "bad",
    "code": "{ config, lib, pkgs, ... }:\nlet\n  cfg = config.services.myService;\nin\n{\n  options.services.myService.enable = lib.mkEnableOption \"My Service\";\n\n  config = lib.mkIf cfg.enable {\n    # Wrong: This is Home Manager syntax\n    home.packages = [ pkgs.myService ];\n    xdg.configFile.\"myservice/config\".text = \"example\";\n  };\n}",
    "language": "nix",
    "description": "Home-manager syntax"
  },
  {
    "ruleId": "",
    "ruleTitle": "NixOS System Module",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption mkOption types;\n  cfg = config.services.myService;\nin\n{\n  options.services.myService = {\n    enable = mkEnableOption \"My Service\";\n\n    port = mkOption {\n      type = types.port;\n      default = 8080;\n      description = \"Port to listen on\";\n    };\n\n    dataDir = mkOption {\n      type = types.path;\n      default = \"/var/lib/myservice\";\n      description = \"Directory for service data\";\n    };\n  };\n\n  config = mkIf cfg.enable {\n    # System-level package installation\n    environment.systemPackages = [ pkgs.myService ];\n\n    # System user for the service\n    users.users.myservice = {\n      isSystemUser = true;\n      group = \"myservice\";\n      home = cfg.dataDir;\n      createHome = true;\n    };\n\n    users.groups.myservice = { };\n\n    # Systemd service definition\n    systemd.services.myservice = {\n      description = \"My Service\";\n      wantedBy = [ \"multi-user.target\" ];\n      after = [ \"network.target\" ];\n\n      serviceConfig = {\n        Type = \"simple\";\n        User = \"myservice\";\n        Group = \"myservice\";\n        ExecStart = \"${pkgs.myService}/bin/myservice --port ${toString cfg.port}\";\n        Restart = \"on-failure\";\n        RestartSec = \"10s\";\n        StateDirectory = \"myservice\";\n        WorkingDirectory = cfg.dataDir;\n      };\n    };\n\n    # Firewall configuration\n    networking.firewall.allowedTCPPorts = [ cfg.port ];\n  };\n}",
    "language": "nix",
    "description": "Systemd Service"
  },
  {
    "ruleId": "",
    "ruleTitle": "Standard Module Structure",
    "type": "bad",
    "code": "{ config, lib, pkgs, ... }:\nlet\n  myPackage = pkgs.hello;\nin\n{\n  # No options defined\n  # No enable flag\n\n  environment.systemPackages = [ myPackage ];\n\n  services.myapp = {\n    enable = true;\n    config = \"hardcoded\";\n  };\n}",
    "language": "nix",
    "description": "Mixing logic"
  },
  {
    "ruleId": "",
    "ruleTitle": "Standard Module Structure",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption mkOption types;\n  cfg = config.services.myapp;\nin\n{\n  options.services.myapp = {\n    enable = mkEnableOption \"My Application\";\n\n    port = mkOption {\n      type = types.port;\n      default = 8080;\n      description = \"Port to listen on\";\n    };\n\n    configFile = mkOption {\n      type = types.path;\n      description = \"Path to configuration file\";\n    };\n  };\n\n  config = mkIf cfg.enable {\n    environment.systemPackages = [ pkgs.myapp ];\n\n    systemd.services.myapp = {\n      wantedBy = [ \"multi-user.target\" ];\n      serviceConfig = {\n        ExecStart = \"${pkgs.myapp}/bin/myapp --port ${toString cfg.port} --config ${cfg.configFile}\";\n        Restart = \"on-failure\";\n      };\n    };\n  };\n}",
    "language": "nix",
    "description": "Standard Pattern"
  },
  {
    "ruleId": "",
    "ruleTitle": "Basic Types",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  ...\n}:\n{\n  options.myService = {\n    enable = lib.mkOption {\n      type = lib.types.bool;\n      default = false;\n      description = \"Enable my service\";\n    };\n\n    # Wrong: Port as string\n    port = lib.mkOption {\n      type = lib.types.str;\n      default = \"8080\";\n    };\n\n    # Wrong: Path as string\n    configPath = lib.mkOption {\n      type = lib.types.str;\n      default = \"/etc/config\";\n    };\n  };\n}",
    "language": "nix",
    "description": "Loose types"
  },
  {
    "ruleId": "",
    "ruleTitle": "Basic Types",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  ...\n}:\nlet\n  inherit (lib) mkEnableOption mkOption types;\nin\n{\n  options.myService = {\n    # mkEnableOption is idiomatic for boolean flags\n    enable = mkEnableOption \"my service\";\n\n    # Port type validates range (0-65535)\n    port = mkOption {\n      type = types.port;\n      default = 8080;\n      description = \"Port to listen on\";\n    };\n\n    # Path type ensures it's a valid path\n    configPath = mkOption {\n      type = types.path;\n      default = /etc/config;\n      description = \"Path to configuration file\";\n    };\n\n    # Int type for numbers\n    workers = mkOption {\n      type = types.ints.positive;\n      default = 4;\n      description = \"Number of worker processes\";\n    };\n\n    # Bool for explicit true/false\n    enableMetrics = mkOption {\n      type = types.bool;\n      default = true;\n      description = \"Enable metrics collection\";\n    };\n  };\n}",
    "language": "nix",
    "description": "Strict types"
  },
  {
    "ruleId": "",
    "ruleTitle": "Collection Types",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  ...\n}:\n{\n  options.myService = {\n    # Wrong: No validation on list items\n    packages = lib.mkOption {\n      type = lib.types.listOf lib.types.any;\n      default = [ ];\n    };\n\n    # Wrong: String instead of enum\n    logLevel = lib.mkOption {\n      type = lib.types.str;\n      default = \"info\";\n    };\n\n    # Wrong: Unstructured attrs\n    settings = lib.mkOption {\n      type = lib.types.attrs;\n      default = { };\n    };\n  };\n}",
    "language": "nix",
    "description": "Untyped lists"
  },
  {
    "ruleId": "",
    "ruleTitle": "Collection Types",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkOption types;\nin\n{\n  options.myService = {\n    # Validated list of packages\n    packages = mkOption {\n      type = types.listOf types.package;\n      default = [ ];\n      description = \"Additional packages to include\";\n    };\n\n    # Enum restricts to specific values\n    logLevel = mkOption {\n      type = types.enum [\n        \"debug\"\n        \"info\"\n        \"warn\"\n        \"error\"\n      ];\n      default = \"info\";\n      description = \"Logging level\";\n    };\n\n    # List of specific strings\n    allowedHosts = mkOption {\n      type = types.listOf types.str;\n      default = [ \"localhost\" ];\n      description = \"Allowed host patterns\";\n    };\n\n    # Structured attrs with type validation\n    environmentVars = mkOption {\n      type = types.attrsOf types.str;\n      default = { };\n      description = \"Environment variables for the service\";\n      example = {\n        API_KEY = \"secret\";\n        DEBUG = \"false\";\n      };\n    };\n  };\n}",
    "language": "nix",
    "description": "Typed collections"
  },
  {
    "ruleId": "",
    "ruleTitle": "Package Options",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\n{\n  options.programs.myEditor = {\n    enable = lib.mkEnableOption \"My Editor\";\n\n    # Works but verbose\n    package = lib.mkOption {\n      type = lib.types.package;\n      default = pkgs.vim;\n      description = \"The vim package to use\";\n    };\n  };\n\n  config = lib.mkIf config.programs.myEditor.enable {\n    environment.systemPackages = [ config.programs.myEditor.package ];\n  };\n}",
    "language": "nix",
    "description": "Manual Default"
  },
  {
    "ruleId": "",
    "ruleTitle": "Package Options",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption mkPackageOption;\n  cfg = config.programs.myEditor;\nin\n{\n  options.programs.myEditor = {\n    enable = mkEnableOption \"My Editor\";\n\n    # Cleaner and generates better documentation\n    package = mkPackageOption pkgs \"git\" { };\n\n    # Can specify alternative package names\n    compiler = mkPackageOption pkgs \"gcc\" {\n      default = \"clang\";\n      example = \"gcc13\";\n    };\n  };\n\n  config = mkIf cfg.enable {\n    environment.systemPackages = [\n      cfg.package\n      cfg.compiler\n    ];\n  };\n}",
    "language": "nix",
    "description": "Helper"
  },
  {
    "ruleId": "",
    "ruleTitle": "Submodule Pattern",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  ...\n}:\n{\n  options.users = lib.mkOption {\n    # Wrong: No validation on inner structure\n    type = lib.types.attrsOf lib.types.attrs;\n    default = { };\n  };\n\n  config = {\n    # Can't validate uid is a number, shell is valid, etc.\n    users.alice = {\n      uid = \"not a number\"; # Should fail but doesn't\n      shell = 12345; # Should be path but isn't\n    };\n  };\n}",
    "language": "nix",
    "description": "Attrs of attrs"
  },
  {
    "ruleId": "",
    "ruleTitle": "Submodule Pattern",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  ...\n}:\nlet\n  inherit (lib) mkOption types;\n\n  userModule = types.submodule {\n    options = {\n      uid = mkOption {\n        type = types.int;\n        description = \"User ID\";\n      };\n\n      shell = mkOption {\n        type = types.path;\n        default = /bin/bash;\n        description = \"User shell\";\n      };\n\n      groups = mkOption {\n        type = types.listOf types.str;\n        default = [ ];\n        description = \"Additional groups\";\n      };\n\n      isAdmin = mkOption {\n        type = types.bool;\n        default = false;\n        description = \"Whether user has admin privileges\";\n      };\n    };\n  };\nin\n{\n  options.users = mkOption {\n    type = types.attrsOf userModule;\n    default = { };\n    description = \"User configurations\";\n    example = {\n      alice = {\n        uid = 1000;\n        shell = /bin/zsh;\n        groups = [\n          \"wheel\"\n          \"docker\"\n        ];\n        isAdmin = true;\n      };\n    };\n  };\n\n  config = {\n    # Now fully validated!\n    users.alice = {\n      uid = 1000;\n      shell = /bin/zsh;\n      groups = [ \"wheel\" ];\n      isAdmin = true;\n    };\n  };\n}",
    "language": "nix",
    "description": "Submodule"
  },
  {
    "ruleId": "",
    "ruleTitle": "Override Functions",
    "type": "bad",
    "code": "{\n  nixpkgs.overlays = [\n    (final: prev: {\n      # DEPRECATED - do not use overrideDerivation\n      myPackage = prev.myPackage.overrideDerivation (old: {\n        buildInputs = old.buildInputs ++ [ prev.newDependency ];\n      });\n    })\n  ];\n}",
    "language": "nix",
    "description": "overrideDerivation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Override Functions",
    "type": "good",
    "code": "{\n  nixpkgs.overlays = [\n    (final: prev: {\n      # Use .override to change function arguments (dependencies)\n      # This replaces the openssl dependency with libressl\n      nginxWithLibreSSL = prev.nginx.override {\n        openssl = prev.libressl;\n      };\n\n      # Use .overrideAttrs to change derivation attributes (most common)\n      # This adds patches, changes build inputs, modifies build phases, etc.\n      patchedNginx = prev.nginx.overrideAttrs (old: {\n        # Add custom patches\n        patches = (old.patches or [ ]) ++ [\n          ./custom-nginx.patch\n        ];\n\n        # Add build-time dependencies\n        buildInputs = old.buildInputs ++ [\n          prev.pcre2\n        ];\n\n        # Modify version string\n        version = \"${old.version}-custom\";\n\n        # Add post-install hook\n        postInstall = (old.postInstall or \"\") + ''\n          echo \"Custom nginx build\" > $out/share/doc/nginx/BUILD_INFO\n        '';\n      });\n    })\n  ];\n}",
    "language": "nix",
    "description": "override vs overrideAttrs"
  },
  {
    "ruleId": "",
    "ruleTitle": "Overlay Structure",
    "type": "bad",
    "code": "{\n  nixpkgs.overlays = [\n    # Old naming convention - deprecated\n    (self: super: {\n      myPackage = super.myPackage.overrideAttrs (old: {\n        version = \"2.0.0\";\n        src = super.fetchurl {\n          url = \"https://example.com/mypackage-2.0.0.tar.gz\";\n          sha256 = \"0000000000000000000000000000000000000000000000000000\";\n        };\n      });\n\n      # This is confusing - which \"self\" are we referring to?\n      customTool = super.stdenv.mkDerivation {\n        name = \"custom-tool\";\n        buildInputs = [ self.myPackage ];\n      };\n    })\n  ];\n}",
    "language": "nix",
    "description": "Deprecated names"
  },
  {
    "ruleId": "",
    "ruleTitle": "Overlay Structure",
    "type": "good",
    "code": "{\n  nixpkgs.overlays = [\n    # Modern naming convention - clear and explicit\n    (final: prev: {\n      myPackage = prev.myPackage.overrideAttrs (old: {\n        version = \"2.0.0\";\n        src = prev.fetchurl {\n          url = \"https://example.com/mypackage-2.0.0.tar.gz\";\n          sha256 = \"0000000000000000000000000000000000000000000000000000\";\n        };\n      });\n\n      # Clear: we want the final version of myPackage (after all overlays)\n      customTool = prev.stdenv.mkDerivation {\n        name = \"custom-tool\";\n        buildInputs = [\n          final.myPackage  # Gets the overridden version\n          prev.git         # Gets original version\n        ];\n      };\n    })\n  ];\n}",
    "language": "nix",
    "description": "Modern Naming"
  },
  {
    "ruleId": "",
    "ruleTitle": "Build Performance",
    "type": "bad",
    "code": "# BAD - no profiling, no idea where time is spent\nnix build .#nixosConfigurations.hostname\n\n# BAD - default settings may not match your hardware\n# Defaults to max jobs = 1, cores = all available\nnix build .#nixosConfigurations.hostname\n\n# BAD - no visibility into what's happening\nnix eval .#nixosConfigurations.hostname",
    "language": "bash",
    "description": "Blind Defaults"
  },
  {
    "ruleId": "",
    "ruleTitle": "Build Performance",
    "type": "good",
    "code": "{\n  nix.settings = {\n    # Tune for your hardware\n    max-jobs = 4;\n    cores = 8;\n\n    # Enable flakes\n    experimental-features = [\n      \"nix-command\"\n      \"flakes\"\n    ];\n\n    # Auto-optimize store\n    auto-optimise-store = true;\n\n    # Configure substituters\n    substituters = [\n      \"https://cache.nixos.org\"\n      \"https://nix-community.cachix.org\"\n    ];\n\n    trusted-public-keys = [\n      \"cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=\"\n      \"nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=\"\n    ];\n  };\n\n  # Automatic garbage collection\n  nix.gc = {\n    automatic = true;\n    dates = \"weekly\";\n    options = \"--delete-older-than 30d\";\n  };\n}",
    "language": "nix",
    "description": "Profiled Build"
  },
  {
    "ruleId": "",
    "ruleTitle": "Closure Size Minimization",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\n\n  # BAD - pulls in entire stdenv (gcc, binutils, etc.) for a simple script\n  myScript = pkgs.stdenv.mkDerivation {\n    name = \"my-script\";\n    buildCommand = ''\n      mkdir -p $out/bin\n      cat > $out/bin/hello <<'EOF'\n      #!/bin/sh\n      echo \"Hello, World!\"\n      EOF\n      chmod +x $out/bin/hello\n    '';\n  };\n\n  # BAD - includes massive dev dependencies in runtime closure\n  myPackage = pkgs.stdenv.mkDerivation {\n    name = \"my-package\";\n    buildInputs = [\n      pkgs.llvm\n      pkgs.clang\n      pkgs.cmake\n    ];\n    # These are only needed at build time, not runtime!\n  };\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n  };\n\n  config = mkIf cfg.enable {\n    environment.systemPackages = [\n      myScript\n      myPackage\n    ];\n  };\n}",
    "language": "nix",
    "description": "Heavy Builder"
  },
  {
    "ruleId": "",
    "ruleTitle": "Closure Size Minimization",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\n\n  # GOOD - minimal closure with writeShellApplication\n  myScript = pkgs.writeShellApplication {\n    name = \"hello\";\n    runtimeInputs = [ pkgs.coreutils ];\n    text = ''\n      echo \"Hello, World!\"\n      date\n    '';\n  };\n\n  # GOOD - split outputs to separate dev dependencies\n  myPackage = pkgs.stdenv.mkDerivation {\n    name = \"my-package\";\n    outputs = [ \"out\" \"dev\" \"doc\" \"lib\" ];\n\n    nativeBuildInputs = [\n      pkgs.llvm\n      pkgs.clang\n      pkgs.cmake\n    ];\n\n    buildInputs = [\n      # Only runtime dependencies here\n      pkgs.openssl\n    ];\n\n    # Move headers to dev output\n    postInstall = ''\n      moveToOutput \"include\" \"$dev\"\n      moveToOutput \"share/doc\" \"$doc\"\n      moveToOutput \"lib/*.a\" \"$dev\"\n    '';\n  };\n\n  # GOOD - use writeText for pure data files\n  configFile = pkgs.writeText \"myconfig.json\" (builtins.toJSON {\n    setting1 = \"value1\";\n    setting2 = \"value2\";\n  });\n\n  # GOOD - use writers for scripts in various languages\n  pythonScript = pkgs.writers.writePython3 \"myscript\" {\n    libraries = [ pkgs.python3Packages.requests ];\n  } ''\n    import requests\n    print(requests.get(\"https://example.com\").text)\n  '';\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n  };\n\n  config = mkIf cfg.enable {\n    environment.systemPackages = [\n      myScript\n      myPackage  # Only includes 'out', not 'dev'\n    ];\n\n    environment.etc.\"myconfig.json\".source = configFile;\n  };\n}",
    "language": "nix",
    "description": "Minimal Builder"
  },
  {
    "ruleId": "",
    "ruleTitle": "Attribute Organization",
    "type": "bad",
    "code": "{ config, lib, pkgs, ... }:\n{\n  options.services.myService.enable = lib.mkEnableOption \"My Service\";\n\n  home.packages = [ pkgs.git ];\n\n  options.services.myService.port = lib.mkOption {\n    type = lib.types.port;\n  };\n\n  programs.vim.enable = true;\n\n  config = lib.mkIf config.services.myService.enable {\n    home.packages = [ pkgs.curl ];\n  };\n}",
    "language": "nix",
    "description": "Scattered configs"
  },
  {
    "ruleId": "",
    "ruleTitle": "Attribute Organization",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption mkOption types;\n  cfg = config.services.myService;\nin\n{\n  imports = [\n    ./submodule.nix\n  ];\n\n  options.services.myService = {\n    enable = mkEnableOption \"My Service\";\n    port = mkOption {\n      type = types.port;\n      default = 8080;\n    };\n  };\n\n  config = mkIf cfg.enable {\n    # Group related settings together\n    programs.git.enable = true;\n    programs.vim.enable = true;\n\n    # Keep package lists consolidated\n    home.packages = with pkgs; [\n      curl\n      wget\n    ];\n\n    # Service-specific config\n    systemd.services.my-service = {\n      wantedBy = [ \"multi-user.target\" ];\n      serviceConfig.ExecStart = \"${pkgs.myService}/bin/start --port ${toString cfg.port}\";\n    };\n  };\n}",
    "language": "nix",
    "description": "Structured"
  },
  {
    "ruleId": "",
    "ruleTitle": "Explicit Destructuring",
    "type": "bad",
    "code": "args:\nargs.stdenv.mkDerivation {\n  pname = \"my-package\";\n  version = \"1.0\";\n\n  src = args.fetchurl {\n    url = \"https://example.com/file.tar.gz\";\n    sha256 = \"0000000000000000000000000000000000000000000000000000\";\n  };\n\n  buildInputs = [ args.openssl args.zlib ];\n}",
    "language": "nix",
    "description": "Opaque Arguments"
  },
  {
    "ruleId": "",
    "ruleTitle": "Explicit Destructuring",
    "type": "good",
    "code": "{\n  stdenv,\n  fetchurl,\n  lib,\n  openssl,\n  zlib,\n}:\n\nstdenv.mkDerivation {\n  pname = \"my-package\";\n  version = \"1.0\";\n\n  src = fetchurl {\n    url = \"https://example.com/file.tar.gz\";\n    sha256 = \"0000000000000000000000000000000000000000000000000000\";\n  };\n\n  buildInputs = [\n    openssl\n    zlib\n  ];\n\n  meta = {\n    description = \"Example package\";\n    license = lib.licenses.mit;\n  };\n}",
    "language": "nix",
    "description": "Self-Documenting"
  },
  {
    "ruleId": "",
    "ruleTitle": "File Naming",
    "type": "bad",
    "code": "# File structure:\n# modules/home/myApp/default.nix\n# modules/nixos/services/my_service.nix\n# modules/darwin/programs/MyProgram/config.nix\n\n# Inconsistent naming across the codebase",
    "language": "nix",
    "description": "Camel or Snake"
  },
  {
    "ruleId": "",
    "ruleTitle": "File Naming",
    "type": "good",
    "code": "# File structure:\n# modules/home/programs/my-app/default.nix\n# modules/nixos/services/my-service.nix\n# modules/darwin/programs/my-program/config.nix\n\n# Consistent, readable, and avoids filesystem issues\n{\n  imports = [\n    ./modules/home/programs/my-app\n    ./modules/nixos/services/my-service\n  ];\n}",
    "language": "nix",
    "description": "kebab-case"
  },
  {
    "ruleId": "",
    "ruleTitle": "Inherit Pattern",
    "type": "bad",
    "code": "{ config, lib, pkgs, ... }:\n{\n  options.myModule = {\n    enable = lib.mkEnableOption \"My Module\";\n    name = lib.mkOption {\n      type = lib.types.str;\n      default = \"default\";\n    };\n  };\n\n  config = lib.mkIf config.myModule.enable {\n    services.foo = lib.mkDefault { };\n  };\n}",
    "language": "nix",
    "description": "Repetitive Prefixing"
  },
  {
    "ruleId": "",
    "ruleTitle": "Inherit Pattern",
    "type": "good",
    "code": "{ config, lib, pkgs, ... }:\nlet\n  inherit (lib) mkIf mkEnableOption mkOption mkDefault types;\nin\n{\n  options.myModule = {\n    enable = mkEnableOption \"My Module\";\n    name = mkOption {\n      type = types.str;\n      default = \"default\";\n    };\n  };\n\n  config = mkIf config.myModule.enable {\n    services.foo = mkDefault { };\n  };\n}",
    "language": "nix",
    "description": "Clean Inherit"
  },
  {
    "ruleId": "",
    "ruleTitle": "Inline Prefix",
    "type": "bad",
    "code": "{ config, lib, ... }:\nlet\n  inherit (lib) mkDefault;\nin\n{\n  config.foo = mkDefault \"bar\";\n}",
    "language": "nix",
    "description": "Over-optimization"
  },
  {
    "ruleId": "",
    "ruleTitle": "Inline Prefix",
    "type": "good",
    "code": "{ config, lib, ... }:\n{\n  config.foo = lib.mkDefault \"bar\";\n  config.baz = lib.mkForce \"qux\";\n}",
    "language": "nix",
    "description": "Direct Access"
  },
  {
    "ruleId": "",
    "ruleTitle": "Prefer let-in over rec",
    "type": "bad",
    "code": "rec {\n  x = y;\n  y = x;\n  # This causes infinite recursion!\n}",
    "language": "nix",
    "description": "Recursive Cycle"
  },
  {
    "ruleId": "",
    "ruleTitle": "Prefer let-in over rec",
    "type": "good",
    "code": "let\n  version = \"1.0\";\n  pname = \"my-app\";\nin\n{\n  inherit pname version;\n  fullName = \"${pname}-${version}\";\n\n  # Dependencies are clear and evaluated in order\n  buildCommand = \"echo Building ${fullName}\";\n}",
    "language": "nix",
    "description": "Clear Separation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Avoid High-Scope With",
    "type": "bad",
    "code": "{ config, lib, ... }:\nwith lib;\n{\n  # types, mkIf, etc. are now magical\n  options.example = mkOption {\n    type = types.str;\n  };\n\n  config = mkIf config.example.enable {\n    # Where does mkIf come from? Unclear!\n  };\n}",
    "language": "nix",
    "description": "Global With"
  },
  {
    "ruleId": "",
    "ruleTitle": "Avoid High-Scope With",
    "type": "good",
    "code": "{ config, lib, pkgs, ... }:\nlet\n  inherit (lib) mkIf mkOption types;\nin\n{\n  options.example = mkOption {\n    type = types.str;\n  };\n\n  config = mkIf config.example.enable {\n    # Single-line usage for lists is acceptable\n    environment.systemPackages = with pkgs; [ git vim curl ];\n  };\n}",
    "language": "nix",
    "description": "Safe With"
  },
  {
    "ruleId": "",
    "ruleTitle": "Variable Naming",
    "type": "bad",
    "code": "let\n  user_name = \"aytordev\";\n  UserName = \"Aytor Dev\";\n  enable_auto_start = true;\n  MAX_retries = 5;\nin\n{\n  # Inconsistent naming makes code harder to read\n}",
    "language": "nix",
    "description": "Mixed styles"
  },
  {
    "ruleId": "",
    "ruleTitle": "Variable Naming",
    "type": "good",
    "code": "let\n  userName = \"aytordev\";\n  fullName = \"Aytor Dev\";\n  enableAutoStart = true;\n  MAX_RETRIES = 5;\n  DEFAULT_PORT = 8080;\nin\n{\n  # Clear distinction between variables and constants\n  services.myapp = {\n    user = userName;\n    autoStart = enableAutoStart;\n    maxRetries = MAX_RETRIES;\n    port = DEFAULT_PORT;\n  };\n}",
    "language": "nix",
    "description": "camelCase"
  },
  {
    "ruleId": "",
    "ruleTitle": "Automated Tools",
    "type": "bad",
    "code": "{config,lib,pkgs,...}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg=config.aytordev.example.module;\n  # Unused variable\n  unused = \"this is never used\";\nin {\n  options.aytordev.example.module={\n    enable=mkEnableOption \"example module\";\n  };\n\n  config=mkIf cfg.enable {\n    # Inconsistent spacing and formatting\n    programs.git.enable=true;\n      programs.bash.enable =  true;\n  };\n}",
    "language": "nix",
    "description": "Unformatted Code"
  },
  {
    "ruleId": "",
    "ruleTitle": "Automated Tools",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n  };\n\n  config = mkIf cfg.enable {\n    programs.git.enable = true;\n    programs.bash.enable = true;\n  };\n}",
    "language": "nix",
    "description": "Automated Pipeline"
  },
  {
    "ruleId": "",
    "ruleTitle": "Common Errors",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\n\n  # Infinite recursion - x depends on y, y depends on x\n  settings = rec {\n    x = y;\n    y = x;\n  };\n\n  # Another common mistake - self-referencing in rec\n  paths = rec {\n    prefix = \"/usr/local\";\n    binDir = \"${prefix}/bin\";\n    # This creates infinite recursion\n    fullPath = \"${fullPath}/extra\";\n  };\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n  };\n\n  config = mkIf cfg.enable {\n    environment.variables.PATH = paths.fullPath;\n  };\n}",
    "language": "nix",
    "description": "Infinite Recursion"
  },
  {
    "ruleId": "",
    "ruleTitle": "Common Errors",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\n\n  # Fixed - no circular dependency\n  settings = {\n    x = \"value\";\n    y = \"value\";\n  };\n\n  # Fixed - use let binding for dependent values\n  paths =\n    let\n      prefix = \"/usr/local\";\n    in\n    {\n      inherit prefix;\n      binDir = \"${prefix}/bin\";\n      libDir = \"${prefix}/lib\";\n      # Build path without self-reference\n      fullPath = \"${prefix}/bin:${prefix}/lib\";\n    };\n\n  # Or avoid rec entirely by using explicit references\n  otherPaths = {\n    prefix = \"/usr/local\";\n    binDir = \"${otherPaths.prefix}/bin\";  # Reference outer attribute\n  };\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n  };\n\n  config = mkIf cfg.enable {\n    environment.variables.PATH = paths.fullPath;\n\n    # Other common error - missing semicolon\n    programs.git.enable = true;  # Don't forget the semicolon\n\n    # Undefined variable - forgot to add lib to function args\n    # Would fail with: undefined variable 'lib'\n    # Fix: Add lib to function arguments at top\n  };\n}",
    "language": "nix",
    "description": "Broken Cycle"
  },
  {
    "ruleId": "",
    "ruleTitle": "Manual Checks",
    "type": "bad",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    # Type mismatch - will fail at evaluation\n    count = lib.mkOption {\n      type = lib.types.int;\n      default = \"not an integer\";  # ERROR\n    };\n  };\n\n  config = mkIf cfg.enable {\n    # Referencing non-existent attribute - will fail\n    programs.nonexistent.enable = true;\n  };\n}",
    "language": "nix",
    "description": "Blind Push"
  },
  {
    "ruleId": "",
    "ruleTitle": "Manual Checks",
    "type": "good",
    "code": "{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\nlet\n  inherit (lib) mkIf mkEnableOption mkOption types;\n  cfg = config.aytordev.example.module;\nin\n{\n  options.aytordev.example.module = {\n    enable = mkEnableOption \"example module\";\n    count = mkOption {\n      type = types.int;\n      default = 5;  # Correct type\n    };\n  };\n\n  config = mkIf cfg.enable {\n    programs.git.enable = true;  # Valid attribute\n  };\n}",
    "language": "nix",
    "description": "Dry Run"
  }
]